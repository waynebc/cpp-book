# 存储类

存储类定义 C++ 程序中变量/函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。下面列出 C++ 程序中可用的存储类：

- auto
- register
- static
- extern
- mutable
- thread_local（C++ 11）

从 C++ 11 开始，auto 关键字不再是 C++ 存储类说明符，且 register 关键字被弃用。

### auto 存储类

C++ 11 以来，auto 关键字用于两种情况：

- 声明变量时根据初始化表达式自动推断该变量的类型、
- 声明函数时函数返回值的占位符。

C++ 98标准中auto关键字用于自动变量的声明，由于使用极少而且多余，C++ 11 中已经删除这一用法。

```c++
auto a = 12.32;	//会自动推断 a 的类型是 double
a = "1231";	//不能把 const char[5] 赋值给 double 类型变量
```

### register 存储类

**用于定义变量存储在寄存器中**

用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小，且不能对它应用一元的 '&' 运算符（因为它没有内存位置）。

定义 'register' 并不意味着变量将被存储在寄存器中，它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制。

### static 存储类

**static** 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，**使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。**

static 修饰符也可以应用于全局变量。**当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内**。

在 C++ 中，**当 static 用在类数据成员上时，会导致仅有一个该成员的副本被类的所有对象共享。**

### extern 存储类

**使用 extern 来得到在其他文件中声明的全局变量或函数**

在多个文件中用 extern 修饰同一变量时，必须有且只有一处对变量进行定义（初始化），不能有多处定义，不能没有定义。

extern 修饰的变量不能自动初始化。

### mutable 存储类

mutable 说明符修饰类对象的非静态成员变量，表示变量是可变的，目的是为了突破 const 的限制。mutable 变量可以在 const 函数中进行修改。

### thread_local 存储类

使用 thread_local 表示变量是线程私有的，每个线程都有其自己的变量副本。

thread_local 说明符可以和 static 和 extern 合并

可以将 thread_local 仅应用于数据声明和定义，thread_local 不能用于函数声明或定义。





